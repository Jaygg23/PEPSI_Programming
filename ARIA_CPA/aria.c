#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

typedef unsigned char BYTE;
typedef uint8_t ARIA_STATE_t[16]; // 128-bit block
typedef uint8_t ARIA128_KEY_t[16]; // 128-bit masterkey

static const uint8_t S1[256] = {
	0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
	0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
	0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
	0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
	0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
	0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
	0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
	0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
	0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
	0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
	0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
	0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
	0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
	0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
	0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
	0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
};
static const uint8_t S1_1[256] = { // S1^{-1} (통상적 S3)
	0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
	0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
	0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
	0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
	0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
	0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
	0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
	0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
	0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
	0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
	0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
	0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
	0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
	0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
	0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
	0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
};
static const uint8_t S2[256] = { // S2
	0xe2,0x4e,0x54,0xfc,0x94,0xc2,0x4a,0xcc,0x62,0x0d,0x6a,0x46,0x3c,0x4d,0x8b,0xd1,
	0x5e,0xfa,0x64,0xcb,0xb4,0x97,0xbe,0x2b,0xbc,0x77,0x2e,0x03,0xd3,0x19,0x59,0xc1,
	0x1d,0x06,0x41,0x6b,0x55,0xf0,0x99,0x69,0xea,0x9c,0x18,0xae,0x63,0xdf,0xe7,0xbb,
	0x00,0x73,0x66,0xfb,0x96,0x4c,0x85,0xe4,0x3a,0x09,0x45,0xaa,0x0f,0xee,0x10,0xeb,
	0x2d,0x7f,0xf4,0x29,0xac,0xcf,0xad,0x91,0x8d,0x78,0xc8,0x95,0xf9,0x2f,0xce,0xcd,
	0x08,0x7a,0x88,0x38,0x5c,0x83,0x2a,0x28,0x47,0xdb,0xb8,0xc7,0x93,0xa4,0x12,0x53,
	0xff,0x87,0x0e,0x31,0x36,0x21,0x58,0x48,0x01,0x8e,0x37,0x74,0x32,0xca,0xe9,0xb1,
	0xb7,0xab,0x0c,0xd7,0xc4,0x56,0x42,0x26,0x07,0x98,0x60,0xd9,0xb6,0xb9,0x11,0x40,
	0xec,0x20,0x8c,0xbd,0xa0,0xc9,0x84,0x04,0x49,0x23,0xf1,0x4f,0x50,0x1f,0x13,0xdc,
	0xd8,0xc0,0x9e,0x57,0xe3,0xc3,0x7b,0x65,0x3b,0x02,0x8f,0x3e,0xe8,0x25,0x92,0xe5,
	0x15,0xdd,0xfd,0x17,0xa9,0xbf,0xd4,0x9a,0x7e,0xc5,0x39,0x67,0xfe,0x76,0x9d,0x43,
	0xa7,0xe1,0xd0,0xf5,0x68,0xf2,0x1b,0x34,0x70,0x05,0xa3,0x8a,0xd5,0x79,0x86,0xa8,
	0x30,0xc6,0x51,0x4b,0x1e,0xa6,0x27,0xf6,0x35,0xd2,0x6e,0x24,0x16,0x82,0x5f,0xda,
	0xe6,0x75,0xa2,0xef,0x2c,0xb2,0x1c,0x9f,0x5d,0x6f,0x80,0x0a,0x72,0x44,0x9b,0x6c,
	0x90,0x0b,0x5b,0x33,0x7d,0x5a,0x52,0xf3,0x61,0xa1,0xf7,0xb0,0xd6,0x3f,0x7c,0x6d,
	0xed,0x14,0xe0,0xa5,0x3d,0x22,0xb3,0xf8,0x89,0xde,0x71,0x1a,0xaf,0xba,0xb5,0x81
};
static const uint8_t S2_1[256] = { // S2^{-1} (통상적 S4)
	0x30,0x68,0x99,0x1b,0x87,0xb9,0x21,0x78,0x50,0x39,0xdb,0xe1,0x72,0x09,0x62,0x3c,
	0x3e,0x7e,0x5e,0x8e,0xf1,0xa0,0xcc,0xa3,0x2a,0x1d,0xfb,0xb6,0xd6,0x20,0xc4,0x8d,
	0x81,0x65,0xf5,0x89,0xcb,0x9d,0x77,0xc6,0x57,0x43,0x56,0x17,0xd4,0x40,0x1a,0x4d,
	0xc0,0x63,0x6c,0xe3,0xb7,0xc8,0x64,0x6a,0x53,0xaa,0x38,0x98,0x0c,0xf4,0x9b,0xed,
	0x7f,0x22,0x76,0xaf,0xdd,0x3a,0x0b,0x58,0x67,0x88,0x06,0xc3,0x35,0x0d,0x01,0x8b,
	0x8c,0xc2,0xe6,0x5f,0x02,0x24,0x75,0x93,0x66,0x1e,0xe5,0xe2,0x54,0xd8,0x10,0xce,
	0x7a,0xe8,0x08,0x2c,0x12,0x97,0x32,0xab,0xb4,0x27,0x0a,0x23,0xdf,0xef,0xca,0xd9,
	0xb8,0xfa,0xdc,0x31,0x6b,0xd1,0xad,0x19,0x49,0xbd,0x51,0x96,0xee,0xe4,0xa8,0x41,
	0xda,0xff,0xcd,0x55,0x86,0x36,0xbe,0x61,0x52,0xf8,0xbb,0x0e,0x82,0x48,0x69,0x9a,
	0xe0,0x47,0x9e,0x5c,0x04,0x4b,0x34,0x15,0x79,0x26,0xa7,0xde,0x29,0xae,0x92,0xd7,
	0x84,0xe9,0xd2,0xba,0x5d,0xf3,0xc5,0xb0,0xbf,0xa4,0x3b,0x71,0x44,0x46,0x2b,0xfc,
	0xeb,0x6f,0xd5,0xf6,0x14,0xfe,0x7c,0x70,0x5a,0x7d,0xfd,0x2f,0x18,0x83,0x16,0xa5,
	0x91,0x1f,0x05,0x95,0x74,0xa9,0xc1,0x5b,0x4a,0x85,0x6d,0x13,0x07,0x4f,0x4e,0x45,
	0xb2,0x0f,0xc9,0x1c,0xa6,0xbc,0xec,0x73,0x90,0x7b,0xcf,0x59,0x8f,0xa1,0xf9,0x2d,
	0xf2,0xb1,0x00,0x94,0x37,0x9f,0xd0,0x2e,0x9c,0x6e,0x28,0x3f,0x80,0xf0,0x3d,0xd3,
	0x25,0x8a,0xb5,0xe7,0x42,0xb3,0xc7,0xea,0xf7,0x4c,0x11,0x33,0x03,0xa2,0xac,0x60
};

void AddRoundKey(unsigned char state[], unsigned char key[]) {
	state[0] ^= key[0];
	state[1] ^= key[1];
	state[2] ^= key[2];
	state[3] ^= key[3];
	state[4] ^= key[4];
	state[5] ^= key[5];
	state[6] ^= key[6];
	state[7] ^= key[7];
	state[8] ^= key[8];
	state[9] ^= key[9];
	state[10] ^= key[10];
	state[11] ^= key[11];
	state[12] ^= key[12];
	state[13] ^= key[13];
	state[14] ^= key[14];
	state[15] ^= key[15];
}
void word_XOR(unsigned char a[], const unsigned char b[]) {
	a[0] ^= b[0];
	a[1] ^= b[1];
	a[2] ^= b[2];
	a[3] ^= b[3];
	a[4] ^= b[4];
	a[5] ^= b[5];
	a[6] ^= b[6];
	a[7] ^= b[7];
	a[8] ^= b[8];
	a[9] ^= b[9];
	a[10] ^= b[10];
	a[11] ^= b[11];
	a[12] ^= b[12];
	a[13] ^= b[13];
	a[14] ^= b[14];
	a[15] ^= b[15];
}
int32_t StatetoWord(uint32_t x) { // 입력값 x (32비트 정수)를 S-box를 통해 바꾼 후, 다시 32비트 정수로 조합하여 반환하는 함수
	uint8_t b0 = (x >> 24) & 0xFF; // 상위 8비트 (24~31번째 비트)를 추출하여 b0에 저장
	uint8_t b1 = (x >> 16) & 0xFF; // 그다음 8비트 (16~23번째 비트)를 추출하여 b1에 저장
	uint8_t b2 = (x >> 8) & 0xFF; // 그다음 8비트 (8~15번째 비트)를 추출하여 b2에 저장
	uint8_t b3 = x & 0xFF; // 하위 8비트 (0~7번째 비트)를 추출하여 b3에 저장

	// substitution 과정
	b0 = S1[b0];
	b1 = S2[b1];
	b2 = S1_1[b2];
	b3 = S2_1[b3];

	return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3; // substitution된 b0~b3를 각각 원래 위치로 shift한 뒤 OR 연산으로 다시 하나의 32비트 워드로 합쳐 반환
}
uint32_t StatetoWord_1(uint32_t x) { // 역변환 (S-box의 적용 순서 반대)
	uint8_t b0 = (x >> 24) & 0xFF;
	uint8_t b1 = (x >> 16) & 0xFF;
	uint8_t b2 = (x >> 8) & 0xFF;
	uint8_t b3 = x & 0xFF;

	b0 = S1_1[b0];
	b1 = S2_1[b1];
	b2 = S1[b2];
	b3 = S2[b3];

	return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
}
void LT_layer(unsigned char state[16]) { // 16바이트 상태에 4바이트 단위 LT 적용하는 함수
	// 목적: 4바이트 단위로 S - box substitution을 적용하는 "선형변환층 (Linear Transformation Layer)"
	for (int i = 0; i < 16; i += 4) { // 0 ,4, 8, 12 루프 수행
		uint32_t word = (state[i] << 24) | (state[i + 1] << 16) | (state[i + 2] << 8) | state[i + 3]; // 4개의 연속된 바이트를 하나의 32비트 워드로 결합
		word = StatetoWord(word); // 위에서 만든 워드에 substitution 함수(StatetoWord) 적용

		// 변환된 워드를 다시 4바이트로 분해하여 state 배열에 덮어쓰기
		state[i] = (word >> 24) & 0xFF;
		state[i + 1] = (word >> 16) & 0xFF;
		state[i + 2] = (word >> 8) & 0xFF;
		state[i + 3] = word & 0xFF;
	}
}
void LT_1_layer(unsigned char state[16]) { // 역변환
	for (int i = 0; i < 16; i += 4) {
		uint32_t word = (state[i] << 24) | (state[i + 1] << 16) | (state[i + 2] << 8) | state[i + 3];
		word = StatetoWord_1(word);
		state[i] = (word >> 24) & 0xFF;
		state[i + 1] = (word >> 16) & 0xFF;
		state[i + 2] = (word >> 8) & 0xFF;
		state[i + 3] = word & 0xFF;
	}
}
void DiffLayer(unsigned char state[]) { // 고정 선형 변환 매트릭스
	unsigned char tmp[16];

	tmp[0] = state[3] ^ state[4] ^ state[6] ^ state[8] ^ state[9] ^ state[13] ^ state[14];
	tmp[1] = state[2] ^ state[5] ^ state[7] ^ state[8] ^ state[9] ^ state[12] ^ state[15];
	tmp[2] = state[1] ^ state[4] ^ state[6] ^ state[10] ^ state[11] ^ state[12] ^ state[15];
	tmp[3] = state[0] ^ state[5] ^ state[7] ^ state[10] ^ state[11] ^ state[13] ^ state[14];

	tmp[4] = state[0] ^ state[2] ^ state[5] ^ state[8] ^ state[11] ^ state[14] ^ state[15];
	tmp[5] = state[1] ^ state[3] ^ state[4] ^ state[9] ^ state[10] ^ state[14] ^ state[15];
	tmp[6] = state[0] ^ state[2] ^ state[7] ^ state[9] ^ state[10] ^ state[12] ^ state[13];
	tmp[7] = state[1] ^ state[3] ^ state[6] ^ state[8] ^ state[11] ^ state[12] ^ state[13];

	tmp[8] = state[0] ^ state[1] ^ state[4] ^ state[7] ^ state[10] ^ state[13] ^ state[15];
	tmp[9] = state[0] ^ state[1] ^ state[5] ^ state[6] ^ state[11] ^ state[12] ^ state[14];
	tmp[10] = state[2] ^ state[3] ^ state[5] ^ state[6] ^ state[8] ^ state[13] ^ state[15];
	tmp[11] = state[2] ^ state[3] ^ state[4] ^ state[7] ^ state[9] ^ state[12] ^ state[14];

	tmp[12] = state[1] ^ state[2] ^ state[6] ^ state[7] ^ state[9] ^ state[11] ^ state[12];
	tmp[13] = state[0] ^ state[3] ^ state[6] ^ state[7] ^ state[8] ^ state[10] ^ state[13];
	tmp[14] = state[0] ^ state[3] ^ state[4] ^ state[5] ^ state[9] ^ state[11] ^ state[14];
	tmp[15] = state[1] ^ state[2] ^ state[4] ^ state[5] ^ state[8] ^ state[10] ^ state[15];

	memcpy(state, tmp, 16);
}
void Fo(unsigned char state[], unsigned char key[]) { // 홀수 라운드 함수
	AddRoundKey(state, key); // state = state ⊕ round_key
	LT_layer(state); // 4바이트 단위로 S-box 변환 (StatetoWord 적용)
	DiffLayer(state); // 16바이트 상태에 선형 확산 적용
}
void Fe(unsigned char state[], unsigned char key[]) { // 짝수 라운드 함수
	AddRoundKey(state, key);
	LT_1_layer(state); // 역 S-box 변환 (StatetoWord_1 사용)
	DiffLayer(state);
}
void Ff(unsigned char state[], unsigned char key_11[], unsigned char key_12[]) { // 12 라운드 함수
	AddRoundKey(state, key_11); // 마지막 라운드에서도 XOR
	LT_1_layer(state);
	AddRoundKey(state, key_12); // 마지막 키로 마무리 XOR
}
void  RoR_128bit(const uint8_t in[16], uint8_t out[16], int n) {
	//n %= 128; // n이 128일 경우, 128로 나눈 나머지만큼 회전
	if (n == 0) { // 회전 비트 수가 0일 경우
		memcpy(out, in, 16); // in을 out에 그대로 복사
		return;
	}

	// 입력을 상위 64비트(high), 하위 64비트(low)로 나눔
	// 128비트 전체 = [high(MSB 64비트)][low(LSB 64비트)]
	uint64_t high = 0, low = 0;
	for (int i = 0; i < 8; i++) {
		high = (high << 8) | in[i]; // in[0] ~ in[7] → high (MSB부터)
		low = (low << 8) | in[i + 8]; // in[8] ~ in[15] → low
	}

	uint64_t new_high, new_low; // 순환 결과 저장 변수

	if (n < 64) { // 128비트를 64비트로 나누었으므로, 오른쪽으로 n비트 회전하면 상/하위 비트가 서로 교환됨
		new_low = (low >> n) | (high << (64 - n));
		// low : 오른쪽으로 n비트 밀어 왼쪽에 n비트 빈 공간, high : 왼쪽으로 n비트 밀어 오른쪽에 n비트 빈 공간 
		// -> 비트 이동한 low와 high를 or 연산하여 new_low에 저장
		// high의 상위 (64 - n)비트가 왼쪽으로 밀려서 오른쪽(64 - n)비트는 0이 되고, high의 상위 n비트는 왼쪽으로 이동해 low의 왼쪽 빈 공간을 채우는 역할
		new_high = (high >> n) | (low << (64 - n));
	}
	else {
		int k = n - 64;
		new_low = (high >> k) | (low << (64 - k));
		new_high = (low >> k) | (high << (64 - k));
	}

	// 다시 바이트 배열로 변환
	for (int i = 7; i >= 0; i--) {
		out[i] = (new_high & 0xFF); // 상위 비트 (& 0xFF로 하위 8비트만 추출)
		out[i + 8] = (new_low & 0xFF); // 하위 비트
		new_high >>= 8;
		new_low >>= 8;
	}
}
void RoL_128bit(const uint8_t in[16], uint8_t out[16], int n) { // 왼쪽
	//n %= 128;
	if (n == 0) {
		memcpy(out, in, 16);
		return;
	}

	// 128비트를 상위 64비트(high), 하위 64비트(low)로 분할
	uint64_t high = 0, low = 0;
	for (int i = 0; i < 8; i++) {
		high = (high << 8) | in[i]; // in[0]이 MSB
		low = (low << 8) | in[i + 8];
	}

	uint64_t new_high, new_low;

	if (n < 64) {
		new_high = (high << n) | (low >> (64 - n));
		new_low = (low << n) | (high >> (64 - n));
	}
	else {
		int k = n - 64;
		new_high = (low << k) | (high >> (64 - k));
		new_low = (high << k) | (low >> (64 - k));
	}

	// 다시 바이트 배열로 저장 (MSB 먼저)
	for (int i = 7; i >= 0; i--) {
		out[i] = (new_high & 0xFF);
		out[i + 8] = (new_low & 0xFF);
		new_high >>= 8;
		new_low >>= 8;
	}
}
void KeySchedule128(unsigned char key[][16]) {
	unsigned char W0[16], W1[16], W2[16], W3[16], tmp[16];

	const unsigned char CK[3][16] = {
		{0x51,0x7c,0xc1,0xb7,0x27,0x22,0x0a,0x94,0xfe,0x13,0xab,0xe8,0xfa,0x9a,0x6e,0xe0},
		{0x6d,0xb1,0x4a,0xcc,0x9e,0x21,0xc8,0x20,0xff,0x28,0xb1,0xd5,0xef,0x5d,0xe2,0xb0},
		{0xdb,0x92,0x37,0x1d,0x21,0x26,0xe9,0x70,0x03,0x24,0x97,0x75,0x04,0xe8,0xc9,0x0e}
	};

	// W0 = KL = masterKey
	memcpy(W0, key[0], 16);

	// W1 = F0(W0 ⊕ CK[0]) ⊕ KR  (KR = 0)
	memcpy(tmp, W0, 16);
	Fo(tmp, CK[0]);
	memcpy(W1, tmp, 16);

	// W2 = Fe(W1 ⊕ CK[1]) ⊕ W0
	memcpy(tmp, W1, 16);
	Fe(tmp, CK[1]);
	AddRoundKey(tmp, W0);
	memcpy(W2, tmp, 16);

	// W3 = F0(W2 ⊕ CK[2]) ⊕ W1
	memcpy(tmp, W2, 16);
	Fo(tmp, CK[2]);
	AddRoundKey(tmp, W1);
	memcpy(W3, tmp, 16);

	// ek0 ~ ek12 생성 (라운드키 생성)
	RoR_128bit(W1, tmp, 19); // ek0
	word_XOR(tmp, W0);
	memcpy(key[0], tmp, 16);

	RoR_128bit(W2, tmp, 19); // ek1
	word_XOR(tmp, W1);
	memcpy(key[1], tmp, 16);

	RoR_128bit(W3, tmp, 19); // ek2
	word_XOR(tmp, W2);
	memcpy(key[2], tmp, 16);

	RoR_128bit(W0, tmp, 19); // ek3
	word_XOR(tmp, W3);
	memcpy(key[3], tmp, 16);

	RoR_128bit(W1, tmp, 31); // ek4
	word_XOR(tmp, W0);
	memcpy(key[4], tmp, 16);

	RoR_128bit(W2, tmp, 31); // ek5
	word_XOR(tmp, W1);
	memcpy(key[5], tmp, 16);

	RoR_128bit(W3, tmp, 31); // ek6
	word_XOR(tmp, W2);
	memcpy(key[6], tmp, 16);

	RoR_128bit(W0, tmp, 31); // ek7
	word_XOR(tmp, W3);
	memcpy(key[7], tmp, 16);

	RoL_128bit(W1, tmp, 61); // ek8
	word_XOR(tmp, W0);
	memcpy(key[8], tmp, 16);

	RoL_128bit(W2, tmp, 61); // ek9
	word_XOR(tmp, W1);
	memcpy(key[9], tmp, 16);

	RoL_128bit(W3, tmp, 61); // ek10
	word_XOR(tmp, W2);
	memcpy(key[10], tmp, 16);

	RoL_128bit(W0, tmp, 61); // ek11
	word_XOR(tmp, W3);
	memcpy(key[11], tmp, 16);

	RoL_128bit(W1, tmp, 31); // ek12
	word_XOR(tmp, W0);
	memcpy(key[12], tmp, 16);

}
void ARIA128_enc(ARIA_STATE_t P, ARIA_STATE_t C, ARIA128_KEY_t K128) {
	unsigned char RoundKey[13][16];

	memcpy(RoundKey[0], K128, 16);
	memcpy(C, P, 16);

	KeySchedule128(RoundKey);

	Fo(C, RoundKey[0]);
	Fe(C, RoundKey[1]);
	Fo(C, RoundKey[2]);
	Fe(C, RoundKey[3]);
	Fo(C, RoundKey[4]);
	Fe(C, RoundKey[5]);
	Fo(C, RoundKey[6]);
	Fe(C, RoundKey[7]);
	Fo(C, RoundKey[8]);
	Fe(C, RoundKey[9]);
	Fo(C, RoundKey[10]);
	Ff(C, RoundKey[11], RoundKey[12]);
}